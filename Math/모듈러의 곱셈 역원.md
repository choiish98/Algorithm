# 모듈러의 곱셈 역원

**모듈 연산**

**분배 법칙**

**곱셈 역원**

**합동식**

**페르마 소정리**

**확장 유클리드 호제법**



## 사전 지식

### 1. 모듈 연산

> 나머지 연산

모듈 연산은 어떤 수 `a`를 `b`로 나누었을 때, 나머지 `c`를 구하는 연산이다.

식은 아래와 같이 표현할 수 있다.



`a % b = c`



### 2. 곱셈 역원

> 곱하였을 때 곱셈 항등원이 되는 수

어떤 수 `x`가 있다고 하면, `1/x`를 곱하면 항상 방정식의 값은 1이 될 것이다.

이를 곱셈 역원이라 하며, 일반적으로 수와 곱셈 역원은 대칭 관계이며 곱하여 1이 되는 두 수를 곱셈 역원이라 한다.



`x * 1/x = 1`



### 3. 합동식

> a % m = b이면,
>
> a와 b는 m에 대하여 합동이다.



이를 수식으로 표현하면 다음과 같다.

```c
a = b (mod m)
```



Ex) mod 5일 때, 1 = 6 = 1

"나머지는 유지된다."



## 정의

> 나눗셈을 곱셈 역원으로 바꾸어 모듈 연산의 분뱁 법칙을 수행



기본적으로 나머지 연산은 **덧셈, 뺄셈, 곱셈에 대해 분배법칙이 성립**한다.

```c
(a + b) % M = {(a & M) + (b % M)} (mod M)
(a - b) % M = {(a & M) - (b % M)} (mod M)
(a * b) % M = {(a & M) * (b % M)} (mod M)
```



하지만, **나눗셈은 분배법칙이 성립하지 않는다.**

```c
(a / b) % M != {(a & M) / (b % M)} (mod M)
```



나눗셈은 분배법칙이 성립하지 않는 이유



따라서 나눗셈을 분배법칙으로 나누는 방법은 역수를 취한 후 곱셈을 수행하는 것이다.

```c
(a / b) % M = {(a & M) * (b^-1 % M)} (mod M)
```



따라서 나머지 연산은 나눗셈을 하는 상황에서 곱셈의 역원을 구하여 분배 법칙을 수행한다.



## 모듈러 연산의 곱셈 역원 구하기

### 1. 페르마의 소정리

> 서로소인 a와 p에 대하여,
>
> a^p = a (mod p)



소수 p에 대해 아래와 같은 두 종류의 집합을 생각해보자.

```c
A = { 1, 2, 3, 4,  ... , p - 2, p - 1 }

B = aA = { a, 2a, 3a, 4a, ... , a(p - 2), a(p - 1) }
단, a와 p는 서로소이다.
```



위의 수식에서 확인할 수 있는 것처럼 A 집합은 소수 p보다 작은 수로 이루어져 있기 때문에 p로 나머지 연산을 적용해도 집합의 원소가 달라지지 않는다.

반면 집합 B를 살펴보면, a와 p가 서로소이기 때문에 서로 나눠 떨어지지 않는다. 따라서 집합 B도 p로 나머지 연산을 적용해도 집합의 원소가 달라지지 않는다.



수식으로 증명하면,

```c
B % p = { a % p, 2a % p, 3a % p, 4a % p, ... , a(p - 2) % p, a(p - 1) % p}

B % p = { 1, 2, 3, 4, ... , p - 2, p - 1} = A

A % p = B % p
```



따라서 이 페르마의 성질을 이용하여 모듈러 연산의 곱셈 역원을 구하면 다음과 같다.

```c
a^p = a (mod p)
a^p-1 = 1 (mod p)
a^p-2 = a^-1 (mod p)
```

이 말인 즉슨, p가 소수라면 a의 나머지 연산의 곱셈 역원 a^-1은 a^p-2이다.



### 2. 확장 유클리드 호제

추후 예정



<h6>참고 자료</h6>

- [yoooopaaaark](https://velog.io/@yoopark/1000000007)
- [baver](http://zetacode.com/math/2016/04/22/modular-multiplicative-inverse.html)




