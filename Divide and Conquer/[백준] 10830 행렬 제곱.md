# [백준] 10830 행렬 제곱

**행렬**

**분할 정복**

**지수 법칙**

**모듈러 연산**



### 문제 및 입출력

![제목 없음](https://user-images.githubusercontent.com/56579239/192132407-ea7041cc-f232-4ece-874a-9fd011342877.png)



### 문제 접근

이 문제는 꽤나 수학적인 접근이 필요한 문제이다.



- **행렬 연산**

첫 번째로, 행렬의 연산을 수행할 줄 알아야한다.



- **분할 정복 & 지수 법칙**

그리고 연산을 한 행렬을 제곱 연산 수행하여야 한다.

이 제곱 연산을 수행하기 위해 필요한 것이 **분할 정복**이다.



왜 분할 정복을 사용하냐면, 

일반적인 연산과 같이 for문을 수행하게 된다면 최대 100,000,000,000번의 제곱을 수행해야하는데

이미 시간 제한을 넘어가기 때문이다.



DP를 사용할 수 있냐고 할 수 있겠지만,

DP는 중복되는 연산에 대해 메모이제이션을 활용하는 것이 장점이기에

분할 정복을 활용하는 것이 타당하다 볼 수 있다.



이때 제곱 수를 분할정복 할 수 있는 수학적 근거는 **지수 법칙**이 되는 것이다.



주의할 점은 짝수이면 쉽게 분할 정복을 하겠지만 홀수일 때가 문제이다.

이는 예를 들어 설명하자면,

```c
// 지수가 짝수인 경우
a^4 = a^2 * a^2;

// 지수가 홀수인 경우
A^5 = A^2 * A^2 * A;
```



따라서 지수가 홀수이면 첫 번째 항을 한번 더 곱해주면 되는 것이다.



- **모듈러 연산**

마지막으로 모듈러 연산의 정의는 다음과 같다.



```c
(a * b) mod C = {(a mod C) * (b mod C)} mod C
```



즉, 지수 법칙을 통해 분할 정복을 사용하여 제곱을 풀이하는 우리의 방식에서 나머지 연산을 수행할 경우에는 

각 경우마다 나머지 연산을 수행하여야 한다는 뜻이다.



이를 모두 고려하여 구현하면 코드는 다음과 같다.



### 코드

```c
#include <iostream>
using namespace std;

long long n, b;
int arr[5][5];
int result[5][5];

void solved(int v1[5][5], int v2[5][5]) {
  int temp[5][5];
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++) {
      temp[i][j] = 0;
      for (int k = 0; k < n; k++)
        temp[i][j] += (v1[i][k] * v2[k][j]);
      temp[i][j] %= 1000;
    }

  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      v1[i][j] = temp[i][j];
}

int main() {
  cin >> n >> b;

  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      cin >> arr[i][j];
    }
    result[i][i] = 1;
  }

  while (b) {
    if (b % 2 == 1) {
      solved(result, arr);
    }
    solved(arr, arr);
    b /= 2;
  }

  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++)
      cout << result[i][j] << ' ';
    cout << "\n";
  }

  return 0;
}
```

